---
layout: post
title: 'Python面试题汇总'
subtitle: ''
date: 2018-02-14
categories: 技术
tags: 面试题
---

**1.如何实现对python列表去重并保持原先顺序**

- 方法1：set

  ~~~python
  l=[1,1,2,2,4,4,3,3]
  print(list(set(l)))
  #[1, 2, 4, 3]
  ~~~

-  方法2：

  ~~~python
  def go_heavy(l):
      new_l=[]
      for i in l:
          if i not in new_l:
              new_l.append(i)
      return new_l

  l=[1,1,2,2,4,4,3,3]
  print(go_heavy(l))
  ~~~

- 方法3：

  ~~~python
  from functools import reduce

  l=[1,1,2,2,4,4,3,3]
  func = lambda x,y:x if y in x else x + [y]
  print(reduce(func, [[], ] + l))
  ~~~

- 方法4：

  ~~~python
  def del_repeat(liebiao):
   for x in liebiao:
    while liebiao.count(x)>1:
     del liebiao[liebiao.index(x)]
   return liebiao
  ~~~

**2.现有两元组(("a"),("b")),(("1"),("2")),请使用匿名函数生成列表[{"a":"1"},{"b","2"}]**

~~~python
t1=(("a"),("b"))
t2=(("1"),("2"))
#方法1
l=lambda t1,t2: [{i:j} for i,j in zip(t1,t2)]
print(l(t1,t2))
#方法2
list(map(lambda t:{t[0]:t[1]},zip(t1,t2)))
~~~

**3.请给出二分查找的python示例代码**

循环版：

~~~python
def binary_search(l,n):
    start=0
    end=len(l)-1
    while start<=end: #如果start>end则代表没有这个数
        mid=(start+end)//2
        if l[mid]==n:
            return mid
        elif l[mid]>n:
            end=mid-1
        else :
            start=mid+1
    return "not found"
~~~

递归版：

```python
def recursion_binary(l,value,start=0,end=len(l)-1):
    '''
    :param l:传入的有序列表
    :param value: 要查找的值
    :param satrt: 列表开始的下标，默认列表第一个数字下标
    :param end:  列表结束的下标，默认列表最后一个数字下标
    :return: 要查找值的下标
    '''
    if start<=end:
        mid=(start+end)//2
        if l[mid]==value:
            return mid
        elif l[mid]>value:
            return recursion_binary(l,value,start,mid-1)
        else:
            return recursion_binary(l,value,mid+1,end)
    else:
        return "not fount"
```

**4.在python字符串格式化中，%和.format主要区别是什么**

>.format可以按关键字传值可以打乱顺序和重用，而且不需要指定字符串还是数字类型

**5.*args,\*\*kwargs在什么情况下会用到，请举例**kwargs应用**

>一般用于传入的参数数量不固定的情况下，*args将多余的位置参数打包成元组，**kwargs将关键字参数打包成字典

示例：

~~~python
def func(**kwargs):
    print(kwargs)

func(a=1,b=2,c=3)
#结果{'a': 1, 'b': 2, 'c': 3}
~~~
**6.选择题**
~~~python
x="foo "
y=2
print (x*y)

# A. foo  B. foo foo   C.foo 2  D.An exception isthrown 

#正确结果：foo foo 
~~~

**7.**

```python
kvps = {'1':1,'2':2}
theCopy = kvps
kvps['1'] = 5
sum = kvps['1'] + theCopy['1']
print(sum)

# 结果：10
```

参考：[深浅拷贝详解](https://blog.ansheng.me/article/python-full-stack-way-depth-copy)

**8.**   sys.path.append('/root/mods')

>A.改变python启动路径
>
>B.改变python当前工作目录 
>
>**C.添加一个新的python模块搜索路径**
>
>D.从mods中移除所有文件夹

9.

~~~python
country_counter = {}

def addone(country):
    if country in country_counter:
        country_counter[country] += 1
    else:
        country_counter[country] = 1
addone('China')
addone('Japan')
addone('china')
print(len(country_counter))

#结果：3 原因：'China'='china'为False
~~~

10.

~~~python
names1 = ['Amir','Barry','Chales','Dao']
names2 = names1 #地址引用
names3 = names1[:] #浅拷贝
names2[0] = 'Alice'
names3[1] = 'Bob'
sum = 0
for ls in (names1,names2,names3):
    if ls[0] == 'Alice':
        sum += 1
    if ls[1] == 'Bob':
        sum += 10
print(sum)

#结果：12  还是深浅拷贝
~~~

