---
layout: post
title: 'Python常用模块-5（re）'
subtitle: '正则和re模块'
date: 2017-07-05
categories: 技术
tags: python常用模块
---

## 正则表达式

正则表达式在线测试：http://tool.chinaz.com/regex/

###定义：

**正则表达式**本身和python没有什么关系，就是**匹配字符串内容的一种规则**。

官方定义：正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。

### 字符组

```
字符组 ： [字符组]
在同一个位置可能出现的各种字符组成了一个字符组，在正则表达式中用[]表示
字符分为很多类，比如数字、字母、标点等等。
假如你现在要求一个位置"只能出现一个数字",那么这个位置上的字符只能是0、1、2...9这10个数之一。
```

| `正则`         | `待匹配字符` | `匹配结果` | `说明`                                                       |
| -------------- | ------------ | ---------- | ------------------------------------------------------------ |
| `[0123456789]` | `8`          | `True`     | `在一个字符组里枚举合法的所有字符，字符组里的任意一个字符和"待匹配字符"相同都视为可以匹配` |
| `[0123456789]` | `a`          | `False`    | `由于字符组中没有"a"字符，所以不能匹配`                      |
| `[0-9]`        | `7`          | `True`     | `也可以用-表示范围,[0-9]就和[0123456789]是一个意思`          |
| `[a-z]`        | `s`          | `True`     | `同样的如果要匹配所有的小写字母，直接用[a-z]就可以表示`      |
| `[A-Z]`        | `B`          | `True`     | `[A-Z]就表示所有的大写字母`                                  |
| `[0-9a-fA-F]`  | `e`          | `True`     | `可以匹配数字，大小写形式的a～f，用来验证十六进制字符`       |

### 字符：

| `元字符` | `匹配内容`                         |
| -------- | ---------------------------------- |
| .        | 匹配除换行符以外的任意字符         |
| \w       | 匹配字母或数字或下划线             |
| \s       | 匹配任意的空白符                   |
| \d       | 匹配数字                           |
| \n       | 匹配一个换行符                     |
| \t       | 匹配一个制表符                     |
| \b       | 匹配一个单词的结尾                 |
| ^        | 匹配字符串的开始                   |
| $        | 匹配字符串的结尾                   |
| \W       | `匹配非字母或数字或下划线`         |
| \D       | `匹配非数字`                       |
| \S       | `匹配非空白符`                     |
| a\|b     | `匹配字符a或字符b`                 |
| ()       | `匹配括号内的表达式，也表示一个组` |
| [...]    | `匹配字符组中的字符`               |
| [^...]   | `匹配除了字符组中字符的所有字符`   |

 

### 量词：

| `量词` | `用法说明`       |
| ------ | ---------------- |
| *      | 重复零次或更多次 |
| +      | 重复一次或更多次 |
| ?      | 重复零次或一次   |
| {n}    | 重复n次          |
| {n,}   | 重复n次或更多次  |
| {n,m}  | 重复n到m次       |

 

###  . ^ $

| 正则 | 待匹配字符   | 匹配结果     | 说明                    |
| ---- | ------------ | ------------ | ----------------------- |
| 海.  | 海燕海娇海东 | 海燕海娇海东 | 匹配所有"海."的字符     |
| ^海. | 海燕海娇海东 | 海燕         | 只从开头匹配第一个"海." |
| 海.$ | 海燕海娇海东 | 海东         | 只匹配结尾的"海.$"      |

 

 ### * + ? { }

| 正则     | 待匹配字符             | 匹配结果               | 说明                                                     |
| -------- | ---------------------- | ---------------------- | -------------------------------------------------------- |
| 李.?     | 李杰和李莲英和李二棍子 | 李杰李莲李二           | ?表示重复零次或一次，即只匹配"李"后面一个任意字符      |
| 李.*     | 李杰和李莲英和李二棍子 | 李杰和李莲英和李二棍子 | *表示重复零次或多次，即匹配"李"后面0或多个任意字符`    |
| 李.+     | 李杰和李莲英和李二棍子 | 李杰和李莲英和李二棍子 | +表示重复一次或多次，即只匹配"李"后面1个或多个任意字符 |
| 李.{1,2} | 李杰和李莲英和李二棍子 | 李杰和李莲英李二棍     | {1,2}匹配1到2次任意字符                                |

 注意：前面的*,+,?等都是贪婪匹配，也就是尽可能匹配，后面加?号使其变成惰性匹配

| 正则  | 待匹配字符             | 匹配结果 | 说明     |
| ----- | ---------------------- | -------- | -------- |
| 李.*? | 李杰和李莲英和李二棍子 | 李李李   | 惰性匹配 |

 

### 字符集［］［^］

| 正则              | 待匹配字符             | 匹配结果           | 说明                                           |
| ----------------- | ---------------------- | ------------------ | ---------------------------------------------- |
| 李[杰莲英二棍子]* | 李杰和李莲英和李二棍子 | 李杰李莲英李二棍子 | 表示匹配"李"字后面[杰莲英二棍子]的字符任意次 |
| 李[ ^和]*          | 李杰和李莲英和李二棍子 | 李杰李莲英李二棍子 | 表示匹配一个不是"和"的字符任意次             |
| [\d]              | 456bdha3               | 4563               | 表示匹配任意一个数字，匹配到4个结果          |
| [\d]+             | 456bdha3               | 4563               | 表示匹配任意个数字，匹配到2个结果           |

 

### 分组 ()与 或 ｜［^］

 身份证号码是一个长度为15或18个字符的字符串，如果是15位则全部由数字组成，首位不能为0；如果是18位，则前17位全部是数字，末位可能是数字或x，下面我们尝试用正则来表示：

| 正则                               | 待匹配字符         | 匹配结果           | 说明                                                         |
| ---------------------------------- | ------------------ | ------------------ | ------------------------------------------------------------ |
| ^[1-9]\d{13,16}[0-9x]$             | 110101198001017032 | 110101198001017032 | 表示可以匹配一个正确的身份证号                               |
| ^[1-9]\d{13,16}[0-9x]$             | 1101011980010170   | 1101011980010170   | 表示也可以匹配这串数字，但这并不是一个正确的身份证号码，它是一个16位的数字 |
| ^[1-9]\d{14}(\d{2}[0-9x])?$        | 1101011980010170   | False              | 现在不会匹配错误的身份证号了()表示分组，将\d{2}[0-9x]分成一组，就可以整体约束他们出现的次数为0-1次 |
| ^([1-9]\d{16}[0-9x]\|[1-9]\d{14})$ | 110105199812067023 | 110105199812067023 | 表示先匹配[1-9]\d{16}[0-9x]如果没有匹配上就匹配[1-9]\d{14} |

 

### 转义符 \

在正则表达式中，有很多有特殊意义的是元字符，比如\d和\s等，如果要在正则中匹配正常的"\d"而不是"数字"就需要对"\"进行转义，变成'\\'。

在python中，无论是正则表达式，还是待匹配的内容，都是以字符串的形式出现的，在字符串中\也有特殊的含义，本身还需要转义。所以如果匹配一次"\d",字符串中要写成'\\d'，那么正则里就要写成"\\\\d",这样就太麻烦了。这个时候我们就用到了r'\d'这个概念，此时的正则是r'\\d'就可以了。

| 正则    | 待匹配字符 | 匹配结果 | 说明                                                         |
| ------- | ---------- | -------- | ------------------------------------------------------------ |
| \d      | \d         | False    | 因为在正则表达式中\是有特殊意义的字符，所以要匹配\d本身，用表达式\d无法匹配 |
| \\d     | \d         | True     | 转义\之后变成\\，即可匹配                                  |
| "\\\\d" | '\\d'      | True     | 如果在python中，字符串中的'\'也需要转义，所以每一个字符串'\'又需要转义一次 |
| r'\\d'  | r'\d'      | True     | 在字符串之前加r，让整个字符串不转义                        |

 

### 贪婪匹配

贪婪匹配：在满足匹配时，匹配尽可能长的字符串，默认情况下，采用贪婪匹配

| 正则  | 待匹配字符          | 匹配结果            | 说明                                                         |
| ----- | ------------------- | ------------------- | ------------------------------------------------------------ |
| <.*>  | <script>...<script> | <script>...<script> | 默认为贪婪匹配模式，会匹配尽量长的字符串                     |
| <.*?> | <script>...<script> | <script><script>    | 加上？为将贪婪匹配模式转为非贪婪匹配模式，会匹配尽量短的字符串 |

几个常用的非贪婪匹配Pattern

```python
*? 重复任意次，但尽可能少重复
+? 重复1次或更多次，但尽可能少重复
?? 重复0次或1次，但尽可能少重复
{n,m}? 重复n到m次，但尽可能少重复
{n,}? 重复n次以上，但尽可能少重复
```



.*?的用法

```python
. 是任意字符
* 是取 0 至 无限长度
? 是非贪婪模式。
何在一起就是 取尽量少的任意字符，一般不会这么单独写，他大多用在：
.*?x

就是取前面任意长度的字符，直到一个x出现
```

## re模块

 



```python
import re

ret = re.findall('a', 'eva egon yuan')  # 返回所有满足匹配条件的结果,放在列表里
print(ret) #结果 : ['a', 'a']

ret = re.search('a', 'eva egon yuan').group()
print(ret) #结果 : 'a'
# 函数会在字符串内查找模式匹配,只到找到第一个匹配然后返回一个包含匹配信息的对象,该对象可以
# 通过调用group()方法得到匹配的字符串,如果字符串没有匹配，则返回None。

ret = re.match('a', 'abc').group()  # 同search,不过是在字符串开始处进行匹配，开始匹配不上返回None
print(ret)
#结果 : 'a'

ret = re.split('[ab]', 'abcd')  # 先按'a'分割得到''和'bcd',在对''和'bcd'分别按'b'分割
print(ret)  # ['', '', 'cd']

ret = re.sub('\d', 'H', 'eva3egon4yuan4', 1)#将数字替换成'H'，参数1表示只替换1个
print(ret) #evaHegon4yuan4

ret = re.subn('\d', 'H', 'eva3egon4yuan4')#将数字替换成'H'，返回元组(替换的结果,替换了多少次)
print(ret)

obj = re.compile('\d{3}')  #将正则表达式编译成为一个 正则表达式对象，规则要匹配的是3个数字
ret = obj.search('abc123eeee') #正则表达式对象调用search，参数为待匹配的字符串
print(ret.group())  #结果 ： 123

import re
ret = re.finditer('\d', 'ds3sy4784a')   #finditer返回一个存放匹配结果的迭代器
print(ret)  # <callable_iterator object at 0x10195f940>
print(next(ret).group())  #查看第一个结果
print(next(ret).group())  #查看第二个结果
print([i.group() for i in ret])  #查看剩余的左右结果
```



注意：

1 findall的优先级查询：



```python
import re

ret = re.findall('www.(baidu|oldboy).com', 'www.oldboy.com')
print(ret)  # ['oldboy']     这是因为findall会优先把匹配结果组里内容返回,如果想要匹配结果,取消权限即可

ret = re.findall('www.(?:baidu|oldboy).com', 'www.oldboy.com')
print(ret)  # ['www.oldboy.com']
```



2 split的优先级查询

```python
ret=re.split("\d+","eva3egon4yuan")
print(ret) #结果 ： ['eva', 'egon', 'yuan']

ret=re.split("(\d+)","eva3egon4yuan")
print(ret) #结果 ： ['eva', '3', 'egon', '4', 'yuan']

#在匹配部分加上（）之后所切出的结果是不同的，
#没有（）的没有保留所匹配的项，但是有（）的却能够保留了匹配的项，
#这个在某些需要保留匹配部分的使用过程是非常重要的。
```



参考自景女神的博客http://www.cnblogs.com/Eva-J/articles/7228075.html#_label10